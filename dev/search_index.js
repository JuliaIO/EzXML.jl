var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This page is dedicated to those who are new to EzXML.jl. It is recommended to read this page before reading other pages to grasp the concepts of the package first. Once you have read it, the reference page would be a better place to find necessary functions. The developer notes page is for developers and most users do not need to read it.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In this manual, we use using EzXML to load the package for brevity.  However, it is recommended to use import EzXML or something similar for non-trivial scripts or packages because EzXML.jl exports a number of names to your environment. These are useful in an interactive session but easily conflict with other names. If you would like to know the list of exported names, please go to the top of src/EzXML.jl, where you will see a long list of type and function names.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"EzXML.jl is built on top of libxml2, a portable C library compliant to the XML standard. If you are not familiar with XML itself, the following links offer good resources to learn the basic concents of XML:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"XML Tutorial\nXML Tree\nXML XPath","category":"page"},{"location":"manual/#Data-types","page":"Manual","title":"Data types","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are two types that constitute an XML document and its components: Document and Node, respectively. The Document type represents a whole XML document. A Document object points to the topmost node of the XML document, but note that it is different from the root node you see in an XML file.  The Node type represents almost everything in an XML document; elements, attributes, texts, CDATAs, comments, documents, etc. are all Node type objects. These two type names are not exported from EzXML.jl because their names are very general and easily conflict with other names exported from other packages.  However, the user can expect them as public APIs and use them with the EzXML. prefix.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Here is an example to create an empty XML document using the XMLDocument constructor:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using EzXML\n\njulia> doc = XMLDocument()\nEzXML.Document(EzXML.Node(<DOCUMENT_NODE@0x00007fd9f1f14370>))\n\njulia> typeof(doc)\nEzXML.Document\n\njulia> doc.node\nEzXML.Node(<DOCUMENT_NODE@0x00007fd9f1f14370>)\n\njulia> typeof(doc.node)\nEzXML.Node\n\njulia> print(doc)  # print an XML-formatted text\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The text just before the @ sign shows the node type (in this example, DOCUMENT_NODE), and the text just after @ shows the pointer address (0x00007fd9f1f14370) to a node struct of libxml2.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's add a root node to the document and a text node to the root node:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> elm = ElementNode(\"root\")  # create an element node\nEzXML.Node(<ELEMENT_NODE[root]@0x00007fd9f2a1b5f0>)\n\njulia> setroot!(doc, elm)\nEzXML.Node(<ELEMENT_NODE[root]@0x00007fd9f2a1b5f0>)\n\njulia> print(doc)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root/>\n\njulia> txt = TextNode(\"some text\")  # create a text node\nEzXML.Node(<TEXT_NODE@0x00007fd9f2a81ee0>)\n\njulia> link!(elm, txt)\nEzXML.Node(<TEXT_NODE@0x00007fd9f2a81ee0>)\n\njulia> print(doc)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>some text</root>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally you can write the document object to a file using the write function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> write(\"out.xml\", doc)\n62\n\njulia> print(String(read(\"out.xml\")))\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>some text</root>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Node object has some properties. The most important one would be the type property, which we already saw in the example above. Other properties (name, path, content and namespace) are demonstrated in the following example. The value of a property will be nothing when there is no corresponding value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> elm = ElementNode(\"element\")\nEzXML.Node(<ELEMENT_NODE[element]@0x00007fd9f44122f0>)\n\njulia> println(elm)\n<element/>\n\njulia> elm.type\nELEMENT_NODE\n\njulia> elm.name\n\"element\"\n\njulia> elm.path\n\"/element\"\n\njulia> elm.content\n\"\"\n\njulia> elm.namespace === nothing\ntrue\n\njulia> elm.name = \"ELEMENT\"  # set element name\n\"ELEMENT\"\n\njulia> println(elm)\n<ELEMENT/>\n\njulia> elm.content = \"some text\"  # set content\n\"some text\"\n\njulia> println(elm)\n<ELEMENT>some text</ELEMENT>\n\njulia> txt = TextNode(\"  text  \")\nEzXML.Node(<TEXT_NODE@0x00007fd9f441f3f0>)\n\njulia> println(txt)\n  text\n\njulia> txt.type\nTEXT_NODE\n\njulia> txt.name\n\"text\"\n\njulia> txt.path\n\"/text()\"\n\njulia> txt.content\n\"  text  \"\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"addelement!(<parent>, <child>, [<content>]) is handy when you want to add a child element to an existing node:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> user = ElementNode(\"User\")\nEzXML.Node(<ELEMENT_NODE[User]@0x00007fd9f427c510>)\n\njulia> println(user)\n<User/>\n\njulia> addelement!(user, \"id\", \"167492\")\nEzXML.Node(<ELEMENT_NODE[id]@0x00007fd9f41ad580>)\n\njulia> println(user)\n<User><id>167492</id></User>\n\njulia> addelement!(user, \"name\", \"Kumiko Oumae\")\nEzXML.Node(<ELEMENT_NODE[name]@0x00007fd9f42942d0>)\n\njulia> println(user)\n<User><id>167492</id><name>Kumiko Oumae</name></User>\n\njulia> prettyprint(user)\n<User>\n  <id>167492</id>\n  <name>Kumiko Oumae</name>\n</User>","category":"page"},{"location":"manual/#DOM","page":"Manual","title":"DOM","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The DOM (Document Object Model) API regards an XML document as a tree of nodes. There is a root node at the top of a document tree and each node has zero or more child nodes. Some nodes (e.g. texts, attributes, etc.) cannot have child nodes.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For the demonstration purpose, save the next XML in \"primates.xml\" file.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<primates>\n    <genus name=\"Homo\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n    <genus name=\"Pan\">\n        <species name=\"paniscus\">Bonobo</species>\n        <species name=\"troglodytes\">Chimpanzee</species>\n    </genus>\n</primates>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readxml(<filename>) reads an XML file and builds a document object in memory. Likewise, parsexml(<string or byte array>) parses an XML string or a byte array in memory and builds a document object:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> doc = readxml(\"primates.xml\")\nEzXML.Document(EzXML.Node(<DOCUMENT_NODE@0x00007fd9f410a5f0>))\n\njulia> data = String(read(\"primates.xml\"));\n\njulia> doc = parsexml(data)\nEzXML.Document(EzXML.Node(<DOCUMENT_NODE@0x00007fd9f4051f80>))\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Before traversing a document we need to get the root of the document tree. The .root property returns the root element (if any) of a document:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> primates = doc.root  # get the root element\nEzXML.Node(<ELEMENT_NODE[primates]@0x00007fd9f4086880>)\n\njulia> genus = elements(primates)  # `elements` returns all child elements.\n2-element Vector{EzXML.Node}:\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\n\njulia> genus[1].type, genus[1].name\n(ELEMENT_NODE, \"genus\")\n\njulia> genus[2].type, genus[2].name\n(ELEMENT_NODE, \"genus\")\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Attribute values can be accessed by its name like a dictionary; haskey, getindex, setindex! and delete! are overloaded for element nodes. Qualified name, which may or may not have the prefix of a namespace, can be used as a key name:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> haskey(genus[1], \"name\")  # check whether an attribute exists\ntrue\n\njulia> genus[1][\"name\"]  # get a value as a string\n\"Homo\"\n\njulia> genus[2][\"name\"]  # same above\n\"Pan\"\n\njulia> println(genus[1])  # print a \"genus\" element before updating\n<genus name=\"Homo\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n\njulia> genus[1][\"taxonID\"] = \"9206\"  # insert a new attribute\n\"9206\"\n\njulia> println(genus[1])  # the \"genus\" element has been updated\n<genus name=\"Homo\" taxonID=\"9206\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In this package, a Node object is regarded as a container of its child nodes. This idea is reflected on its property and function names; for example, a property returning the first child node is named as .firstnode instead of .firstchildnode. All properties and functions provided by the EzXML module are named in this way, and the tree traversal API of a node works on its child nodes by default. Properties (functions) with a direction prefix work on that direction; for example, .nextnode returns the next sibling node and .parentnode returns the parent node.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Distinction between nodes and elements is what every user should know about before using the DOM API.  There are good explanations on this topic: http://www.w3schools.com/xml/dom_nodes.asp, http://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml. Some properties (functions) have a suffix like node or element that indicate a node type the property (function) is interested in. For example, .firstnode returns the first child node (if any), which may be a text node, but .firstelement always returns the first element node (if any):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> primates.firstnode\nEzXML.Node(<TEXT_NODE@0x00007fd9f409f200>)\n\njulia> primates.firstelement\nEzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\n\njulia> primates.firstelement == genus[1]\ntrue\n\njulia> primates.lastnode\nEzXML.Node(<TEXT_NODE@0x00007fd9f404bec0>)\n\njulia> primates.lastelement\nEzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\n\njulia> primates.lastelement === genus[2]\ntrue\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Tree traversal properties return nothing when there is no corresponding node:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> primates.firstelement.nextelement === primates.lastelement\ntrue\n\njulia> primates.firstelement.prevelement === nothing\ntrue\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Here is the list of tree traversal properties:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Document type:\n.root\n.dtd\nThe Node type:\n.document\n.parentnode\n.parentelement\n.firstnode\n.firstelement\n.lastelement\n.lastnode\n.nextnode\n.nextelement\n.nextnode\n.prevnode","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you would like to iterate over child nodes or elements, you can use the eachnode(<parent node>) or the eachelement(<parent node>) function.  The eachnode function generates all nodes including texts, elements, comments, and so on, while eachelement selects only element nodes. nodes(<parent node>) and elements(<parent node>) are handy functions that return a vector of nodes and elements, respectively:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> for node in eachnode(primates)\n           @show node\n       end\nnode = EzXML.Node(<TEXT_NODE@0x00007fd9f409f200>)\nnode = EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\nnode = EzXML.Node(<TEXT_NODE@0x00007fd9f4060f70>)\nnode = EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\nnode = EzXML.Node(<TEXT_NODE@0x00007fd9f404bec0>)\n\njulia> for node in eachelement(primates)\n           @show node\n       end\nnode = EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\nnode = EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\n\njulia> nodes(primates)\n5-element Vector{EzXML.Node}:\n EzXML.Node(<TEXT_NODE@0x00007fd9f409f200>)\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\n EzXML.Node(<TEXT_NODE@0x00007fd9f4060f70>)\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\n EzXML.Node(<TEXT_NODE@0x00007fd9f404bec0>)\n\njulia> elements(primates)\n2-element Vector{EzXML.Node}:\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f4041a40>)\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fd9f40828e0>)\n","category":"page"},{"location":"manual/#XPath","page":"Manual","title":"XPath","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"XPath is a query language for XML. You can retrieve target elements using a short query string. For example, \"//genus/species\" selects all \"species\" elements just under a \"genus\" element.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The findall, findfirst and findlast functions are overloaded for XPath query and return a vector of selected nodes:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> primates = readxml(\"primates.xml\")\nEzXML.Document(EzXML.Node(<DOCUMENT_NODE@0x00007fbeddc2a1d0>))\n\njulia> findall(\"/primates\", primates)  # Find the \"primates\" element just under the document\n1-element Vector{EzXML.Node}:\n EzXML.Node(<ELEMENT_NODE[primates]@0x00007fbeddc1e190>)\n\njulia> findall(\"//genus\", primates)\n2-element Vector{EzXML.Node}:\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fbeddc12c50>)\n EzXML.Node(<ELEMENT_NODE[genus]@0x00007fbeddc16ea0>)\n\njulia> findfirst(\"//genus\", primates)\nEzXML.Node(<ELEMENT_NODE[genus]@0x00007fbeddc12c50>)\n\njulia> findlast(\"//genus\", primates)\nEzXML.Node(<ELEMENT_NODE[genus]@0x00007fbeddc16ea0>)\n\njulia> println(findfirst(\"//genus\", primates))\n<genus name=\"Homo\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you would like to change the starting node of a query, you can pass the node as the second argument of find*:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> genus = findfirst(\"//genus\", primates)\nEzXML.Node(<ELEMENT_NODE[genus]@0x00007fbeddc12c50>)\n\njulia> println(genus)\n<genus name=\"Homo\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n\njulia> println(findfirst(\"species\", genus))\n<species name=\"sapiens\">Human</species>\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"find*(<xpath>, <node>) automatically registers namespaces applied to <node>, which means prefixes are available in the XPath query. This is especially useful when an XML document is composed of elements originated from different namespaces.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There is a caveat on the combination of XPath and namespaces: if a document contains elements with a default namespace, you need to specify its prefix to the find* function. For example, in the following example, the root element and its descendants have a default namespace \"http://www.foobar.org\", but it does not have its own prefix.  In this case, you need to assign a prefix to the namespance when finding elements in the namespace:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> doc = parsexml(\"\"\"\n       <parent xmlns=\"http://www.foobar.org\">\n           <child/>\n       </parent>\n       \"\"\")\nEzXML.Document(EzXML.Node(<DOCUMENT_NODE@0x00007fdc67710030>))\n\njulia> findall(\"/parent/child\", doc.root)  # nothing will be found\nEzXML.Node[]\n\njulia> namespaces(doc.root)  # the default namespace has an empty prefix\n1-element Vector{Pair{String, String}}:\n \"\" => \"http://www.foobar.org\"\n\njulia> ns = namespace(doc.root)  # get the namespace\n\"http://www.foobar.org\"\n\njulia> findall(\"/x:parent/x:child\", doc.root, [\"x\"=>ns])  # specify its prefix as \"x\"\n1-element Vector{EzXML.Node}:\n EzXML.Node(<ELEMENT_NODE[child]@0x00007fdc6774c990>)\n","category":"page"},{"location":"manual/#Streaming-API","page":"Manual","title":"Streaming API","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In addition to the DOM API, EzXML.jl provides a streaming reader of XML files. The streaming reader processes, as the name suggests, a stream of XML data by incrementally reading data from a file instead of reading a whole XML tree into the memory. This enables processing extremely large files with limited memory.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's use the following XML file (undirected.graphml) that represents an undirected graph in the GraphML format (slightly simplified for brevity):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<graphml>\n    <graph edgedefault=\"undirected\">\n        <node id=\"n0\"/>\n        <node id=\"n1\"/>\n        <node id=\"n2\"/>\n        <node id=\"n3\"/>\n        <node id=\"n4\"/>\n        <edge source=\"n0\" target=\"n2\"/>\n        <edge source=\"n1\" target=\"n2\"/>\n        <edge source=\"n2\" target=\"n3\"/>\n        <edge source=\"n3\" target=\"n4\"/>\n    </graph>\n</graphml>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The API of a streaming reader is quite different from the DOM API.  The first thing you needs to do is to create an EzXML.StreamReader object using the open function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> reader = open(EzXML.StreamReader, \"undirected.graphml\")\nEzXML.StreamReader(<READER_NONE@0x00007f9fe8d67340>)\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The stream reader is stateful and parses components by pulling them from the stream. For example, when it reads an element from the stream, it changes the state to READER_ELEMENT and some information becomes accessible.  Its reading state is advanced by the iterate(reader) method:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> reader.type  # the initial state is READER_NONE\nREADER_NONE\n\njulia> iterate(reader);  # advance the reader's state\n\njulia> reader.type  # now the state is READER_ELEMENT\nREADER_ELEMENT\n\njulia> reader.name  # the reader has just read a \"<graphml>\" element\n\"graphml\"\n\njulia> iterate(reader);\n\njulia> reader.type  # now the state is READER_SIGNIFICANT_WHITESPACE\nREADER_SIGNIFICANT_WHITESPACE\n\njulia> reader.name\n\"#text\"\n\njulia> iterate(reader);\n\njulia> reader.type\nREADER_ELEMENT\n\njulia> reader.name  # the reader has just read a \"<graph>\" element\n\"graph\"\n\njulia> reader[\"edgedefault\"]  # attributes are accessible\n\"undirected\"\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"While reading data, a stream reader provides the following properties:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":".type:  node type it has read\n.depth: depth of the current node\n.name: name of the current node\n.content: content of the current node\n.namespace: namespace of the current node","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"iterate(reader) returns nothing to indicate that there are no more data available from the file. When you finished reading data, you need to call close(reader) to release allocated resources:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> reader = open(EzXML.StreamReader, \"undirected.graphml\")\nEzXML.StreamReader(<READER_NONE@0x00007fd642e80d90>)\n\njulia> while (item = iterate(reader)) != nothing\n           @show reader.type, reader.name\n       end\n(reader.type, reader.name) = (READER_ELEMENT, \"graphml\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"graph\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"node\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"node\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"node\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"node\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"node\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"edge\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"edge\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"edge\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_ELEMENT, \"edge\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_END_ELEMENT, \"graph\")\n(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(reader.type, reader.name) = (READER_END_ELEMENT, \"graphml\")\n\njulia> reader.type, reader.name\n(READER_NONE, nothing)\n\njulia> close(reader)  # close the reader\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The open(...) do ... end pattern can be written as:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> open(EzXML.StreamReader, \"undirected.graphml\") do reader\n           # do something\n       end\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"EzXML.jl overloads the Base.iterate function to make a streaming reader iterable via the for loop. Therefore, you can iterate over all components without explicitly calling iterate as follows:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> reader = open(EzXML.StreamReader, \"undirected.graphml\")\nEzXML.StreamReader(<READER_NONE@0x00007fd642e9a6b0>)\n\njulia> for typ in reader\n           @show typ, reader.name\n       end\n(typ, reader.name) = (READER_ELEMENT, \"graphml\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"graph\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"node\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"node\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"node\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"node\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"node\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"edge\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"edge\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"edge\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_ELEMENT, \"edge\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_END_ELEMENT, \"graph\")\n(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, \"#text\")\n(typ, reader.name) = (READER_END_ELEMENT, \"graphml\")\n\njulia> close(reader)\n","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/#EzXML.Document","page":"Reference","title":"EzXML.Document","text":"An XML/HTML document type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EzXML.Node","page":"Reference","title":"EzXML.Node","text":"A proxy type to libxml2's node struct.\n\nProperties\n\nName Type Description\ntype EzXML.NodeType the type of a node\nname String? the name of a node\npath String the absolute path to a node\ncontent String the content of a node\nnamespace String? the namespace associated with a node\n\n\n\n\n\n","category":"type"},{"location":"reference/#EzXML.StreamReader","page":"Reference","title":"EzXML.StreamReader","text":"A streaming XML reader type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EzXML.XMLError","page":"Reference","title":"EzXML.XMLError","text":"An error detected by libxml2.\n\n\n\n\n\n","category":"type"},{"location":"reference/#I/O","page":"Reference","title":"I/O","text":"","category":"section"},{"location":"reference/#EzXML.parsexml","page":"Reference","title":"EzXML.parsexml","text":"parsexml(xmlstring; options...)\n\nParse xmlstring and create an XML document.\n\nParsing Options\n\nnoerror = false: suppress (recoverable) error reports\nnowarning = false: suppress warning reports\npedantic = false: pedantic error reporting\nnoblanks = false: remove blank nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.parsehtml","page":"Reference","title":"EzXML.parsehtml","text":"parsehtml(htmlstring; options...)\n\nParse htmlstring and create an HTML document.\n\nSee parsexml for parsing options.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.readxml","page":"Reference","title":"EzXML.readxml","text":"readxml(filename; options...)\n\nRead filename and create an XML document.\n\nSee parsexml for parsing options.\n\n\n\n\n\nreadxml(input::IO; options...)\n\nRead input and create an XML document.\n\nSee parsexml for parsing options.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.readhtml","page":"Reference","title":"EzXML.readhtml","text":"readhtml(filename; options...)\n\nRead filename and create an HTML document.\n\nSee parsexml for parsing options.\n\n\n\n\n\nreadhtml(input::IO; options...)\n\nRead input and create an HTML document.\n\nSee parsexml for parsing options.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.prettyprint","page":"Reference","title":"EzXML.prettyprint","text":"prettyprint([io], node::Node)\n\nPrint node with formatting.\n\n\n\n\n\nprettyprint([io], doc::Document)\n\nPrint doc with formatting.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Constructors","page":"Reference","title":"Constructors","text":"","category":"section"},{"location":"reference/#EzXML.XMLDocument","page":"Reference","title":"EzXML.XMLDocument","text":"XMLDocument(version=\"1.0\")\n\nCreate an XML document.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.HTMLDocument","page":"Reference","title":"EzXML.HTMLDocument","text":"HTMLDocument(uri=nothing, externalID=nothing)\n\nCreate an HTML document.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.XMLDocumentNode","page":"Reference","title":"EzXML.XMLDocumentNode","text":"XMLDocumentNode(version)\n\nCreate an XML document node with version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.HTMLDocumentNode","page":"Reference","title":"EzXML.HTMLDocumentNode","text":"HTMLDocumentNode(uri, externalID)\n\nCreate an HTML document node.\n\nuri and externalID are either a string or nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.ElementNode","page":"Reference","title":"EzXML.ElementNode","text":"ElementNode(name)\n\nCreate an element node with name.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.TextNode","page":"Reference","title":"EzXML.TextNode","text":"TextNode(content)\n\nCreate a text node with content.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.CommentNode","page":"Reference","title":"EzXML.CommentNode","text":"CommentNode(content)\n\nCreate a comment node with content.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.CDataNode","page":"Reference","title":"EzXML.CDataNode","text":"CDataNode(content)\n\nCreate a CDATA node with content.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.AttributeNode","page":"Reference","title":"EzXML.AttributeNode","text":"AttributeNode(name, value)\n\nCreate an attribute node with name and value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.DTDNode","page":"Reference","title":"EzXML.DTDNode","text":"DTDNode(name, [systemID, [externalID]])\n\nCreate a DTD node with name, systemID, and externalID.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Node-types","page":"Reference","title":"Node types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Node type Integer\nEzXML.ELEMENT_NODE 1\nEzXML.ATTRIBUTE_NODE 2\nEzXML.TEXT_NODE 3\nEzXML.CDATA_SECTION_NODE 4\nEzXML.ENTITY_REF_NODE 5\nEzXML.ENTITY_NODE 6\nEzXML.PI_NODE 7\nEzXML.COMMENT_NODE 8\nEzXML.DOCUMENT_NODE 9\nEzXML.DOCUMENT_TYPE_NODE 10\nEzXML.DOCUMENT_FRAG_NODE 11\nEzXML.NOTATION_NODE 12\nEzXML.HTML_DOCUMENT_NODE 13\nEzXML.DTD_NODE 14\nEzXML.ELEMENT_DECL 15\nEzXML.ATTRIBUTE_DECL 16\nEzXML.ENTITY_DECL 17\nEzXML.NAMESPACE_DECL 18\nEzXML.XINCLUDE_START 19\nEzXML.XINCLUDE_END 20\nEzXML.DOCB_DOCUMENT_NODE 21","category":"page"},{"location":"reference/#Node-accessors","page":"Reference","title":"Node accessors","text":"","category":"section"},{"location":"reference/#EzXML.nodetype-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.nodetype","text":"nodetype(node::Node)\n\nReturn the type of node as an integer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodepath-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.nodepath","text":"nodepath(node::Node)\n\nReturn the path of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodename-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.nodename","text":"nodename(node::Node)\n\nReturn the node name of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodecontent-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.nodecontent","text":"nodecontent(node::Node)\n\nReturn the node content of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.namespace-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.namespace","text":"namespace(node::Node)\n\nReturn the namespace associated with node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.namespaces-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.namespaces","text":"namespaces(node::Node)\n\nCreate a vector of namespaces applying to node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.hasnodename-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.hasnodename","text":"hasnodename(node::Node)\n\nReturn if node has a node name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.hasnamespace-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.hasnamespace","text":"hasnamespace(node::Node)\n\nReturn if node is associated with a namespace.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.iselement-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.iselement","text":"iselement(node::Node)\n\nReturn if node is an element node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.isattribute-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.isattribute","text":"isattribute(node::Node)\n\nReturn if node is an attribute node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.istext-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.istext","text":"istext(node::Node)\n\nReturn if node is a text node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.iscdata-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.iscdata","text":"iscdata(node::Node)\n\nReturn if node is a CDATA node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.iscomment-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.iscomment","text":"iscomment(node::Node)\n\nReturn if node is a comment node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.isdtd-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.isdtd","text":"isdtd(node::Node)\n\nReturn if node is a DTD node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.countnodes-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.countnodes","text":"countnodes(parent::Node)\n\nCount the number of child nodes of parent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.countelements-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.countelements","text":"countelements(parent::Node)\n\nCount the number of child elements of parent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.countattributes-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.countattributes","text":"countattributes(elem::Node)\n\nCount the number of attributes of elem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.systemID-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.systemID","text":"systemID(node::Node)\n\nReturn the system ID of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.externalID-Tuple{EzXML.Node}","page":"Reference","title":"EzXML.externalID","text":"externalID(node::Node)\n\nReturn the external ID of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Node-modifiers","page":"Reference","title":"Node modifiers","text":"","category":"section"},{"location":"reference/#EzXML.setnodename!-Tuple{EzXML.Node, AbstractString}","page":"Reference","title":"EzXML.setnodename!","text":"setnodename!(node::Node, name::AbstractString)\n\nSet the name of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.setnodecontent!-Tuple{EzXML.Node, AbstractString}","page":"Reference","title":"EzXML.setnodecontent!","text":"setnodecontent!(node::Node, content::AbstractString)\n\nReplace the content of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Document-properties","page":"Reference","title":"Document properties","text":"","category":"section"},{"location":"reference/#EzXML.version","page":"Reference","title":"EzXML.version","text":"version(doc::Document)\n\nReturn the version string of doc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.encoding","page":"Reference","title":"EzXML.encoding","text":"encoding(doc::Document)\n\nReturn the encoding string of doc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasversion","page":"Reference","title":"EzXML.hasversion","text":"hasversion(doc::Document)\n\nReturn if doc has a version string.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasencoding","page":"Reference","title":"EzXML.hasencoding","text":"hasencoding(doc::Document)\n\nReturn if doc has an encoding string.\n\n\n\n\n\n","category":"function"},{"location":"reference/#DOM-tree-accessors","page":"Reference","title":"DOM tree accessors","text":"","category":"section"},{"location":"reference/#EzXML.document","page":"Reference","title":"EzXML.document","text":"document(node::Node)\n\nReturn the document of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.root","page":"Reference","title":"EzXML.root","text":"root(doc::Document)\n\nReturn the root element of doc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.dtd","page":"Reference","title":"EzXML.dtd","text":"dtd(doc::Document)\n\nReturn the DTD node of doc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.parentnode","page":"Reference","title":"EzXML.parentnode","text":"parentnode(node::Node)\n\nReturn the parent of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.parentelement","page":"Reference","title":"EzXML.parentelement","text":"parentelement(node::Node)\n\nReturn the parent element of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.firstnode","page":"Reference","title":"EzXML.firstnode","text":"firstnode(node::Node)\n\nReturn the first child node of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.lastnode","page":"Reference","title":"EzXML.lastnode","text":"lastnode(node::Node)\n\nReturn the last child node of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.firstelement","page":"Reference","title":"EzXML.firstelement","text":"firstelement(node::Node)\n\nReturn the first child element of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.lastelement","page":"Reference","title":"EzXML.lastelement","text":"lastelement(node::Node)\n\nReturn the last child element of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.nextnode","page":"Reference","title":"EzXML.nextnode","text":"nextnode(node::Node)\n\nReturn the next node of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.prevnode","page":"Reference","title":"EzXML.prevnode","text":"prevnode(node::Node)\n\nReturn the previous node of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.nextelement","page":"Reference","title":"EzXML.nextelement","text":"nextelement(node::Node)\n\nReturn the next element of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.prevelement","page":"Reference","title":"EzXML.prevelement","text":"prevelement(node::Node)\n\nReturn the previous element of node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.eachnode","page":"Reference","title":"EzXML.eachnode","text":"eachnode(node::Node, [backward=false])\n\nCreate an iterator of child nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.nodes","page":"Reference","title":"EzXML.nodes","text":"nodes(node::Node, [backward=false])\n\nCreate a vector of child nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.eachelement","page":"Reference","title":"EzXML.eachelement","text":"eachelement(node::Node, [backward=false])\n\nCreate an iterator of child elements.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.elements","page":"Reference","title":"EzXML.elements","text":"elements(node::Node, [backward=false])\n\nCreate a vector of child elements.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.eachattribute","page":"Reference","title":"EzXML.eachattribute","text":"eachattribute(node::Node)\n\nCreate an iterator of attributes.\n\n\n\n\n\neachattribute(reader::StreamReader)\n\nReturn an AttributeReader object for the current node of reader\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.attributes","page":"Reference","title":"EzXML.attributes","text":"attributes(node::Node)\n\nCreate a vector of attributes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasroot","page":"Reference","title":"EzXML.hasroot","text":"hasroot(doc::Document)\n\nReturn if doc has a root element.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasdtd","page":"Reference","title":"EzXML.hasdtd","text":"hasdtd(doc::Document)\n\nReturn if doc has a DTD node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasnode","page":"Reference","title":"EzXML.hasnode","text":"hasnode(node::Node)\n\nReturn if node has a child node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasnextnode","page":"Reference","title":"EzXML.hasnextnode","text":"hasnextnode(node::Node)\n\nReturn if node has a next node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasprevnode","page":"Reference","title":"EzXML.hasprevnode","text":"hasprevnode(node::Node)\n\nReturn if node has a previous node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.haselement","page":"Reference","title":"EzXML.haselement","text":"haselement(node::Node)\n\nReturn if node has a child element.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasnextelement","page":"Reference","title":"EzXML.hasnextelement","text":"hasnextelement(node::Node)\n\nReturn if node has a next node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasprevelement","page":"Reference","title":"EzXML.hasprevelement","text":"hasprevelement(node::Node)\n\nReturn if node has a previous node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasdocument","page":"Reference","title":"EzXML.hasdocument","text":"hasdocument(node::Node)\n\nReturn if node belongs to a document.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasparentnode","page":"Reference","title":"EzXML.hasparentnode","text":"hasparentnode(node::Node)\n\nReturn if node has a parent node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.hasparentelement","page":"Reference","title":"EzXML.hasparentelement","text":"hasparentelement(node::Node)\n\nReturn if node has a parent node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#DOM-tree-modifiers","page":"Reference","title":"DOM tree modifiers","text":"","category":"section"},{"location":"reference/#EzXML.setroot!","page":"Reference","title":"EzXML.setroot!","text":"setroot!(doc::Document, node::Node)\n\nSet the root element of doc to node and return the root element.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.setdtd!","page":"Reference","title":"EzXML.setdtd!","text":"setdtd!(doc::Document, node::Node)\n\nSet the DTD node of doc to node and return the DTD node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.link!","page":"Reference","title":"EzXML.link!","text":"link!(parent::Node, child::Node)\n\nLink child at the end of children of parent.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.linknext!","page":"Reference","title":"EzXML.linknext!","text":"linknext!(target::Node, node::Node)\n\nLink node as the next sibling of target.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.linkprev!","page":"Reference","title":"EzXML.linkprev!","text":"linkprev!(target::Node, node::Node)\n\nLink node as the prev sibling of target.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.unlink!","page":"Reference","title":"EzXML.unlink!","text":"unlink!(node::Node)\n\nUnlink node from its context.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.addelement!","page":"Reference","title":"EzXML.addelement!","text":"addelement!(parent::Node, name::AbstractString)\n\nAdd a new child element of name with no content to parent and return the new child element.\n\n\n\n\n\naddelement!(parent::Node, name::AbstractString, content::AbstractString)\n\nAdd a new child element of name with content to parent and return the new child element.\n\n\n\n\n\n","category":"function"},{"location":"reference/#XPath-query","page":"Reference","title":"XPath query","text":"","category":"section"},{"location":"reference/#Base.findall-Tuple{AbstractString, EzXML.Document}","page":"Reference","title":"Base.findall","text":"findall(xpath::AbstractString, doc::Document)\n\nFind nodes matching xpath XPath query from doc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.findfirst-Tuple{AbstractString, EzXML.Document}","page":"Reference","title":"Base.findfirst","text":"findfirst(xpath::AbstractString, doc::Document)\n\nFind the first node matching xpath XPath query from doc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.findlast-Tuple{AbstractString, EzXML.Document}","page":"Reference","title":"Base.findlast","text":"findlast(doc::Document, xpath::AbstractString)\n\nFind the last node matching xpath XPath query from doc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.findall-Tuple{AbstractString, EzXML.Node}","page":"Reference","title":"Base.findall","text":"findall(xpath::AbstractString, node::Node, [ns=namespaces(node)])\n\nFind nodes matching xpath XPath query starting from node.\n\nThe ns argument is an iterator of namespace prefix and URI pairs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.findfirst-Tuple{AbstractString, EzXML.Node}","page":"Reference","title":"Base.findfirst","text":"findfirst(xpath::AbstractString, node::Node, [ns=namespaces(node)])\n\nFind the first node matching xpath XPath query starting from node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.findlast-Tuple{AbstractString, EzXML.Node}","page":"Reference","title":"Base.findlast","text":"findlast(node::Node, xpath::AbstractString, [ns=namespaces(node)])\n\nFind the last node matching xpath XPath query starting from node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Validation","page":"Reference","title":"Validation","text":"","category":"section"},{"location":"reference/#EzXML.validate","page":"Reference","title":"EzXML.validate","text":"validate(doc::Document, [dtd::Node])\n\nValidate doc against dtd and return the validation log.\n\nThe validation log is empty if and only if doc is valid. The DTD node in doc will be used if dtd is not passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EzXML.readdtd","page":"Reference","title":"EzXML.readdtd","text":"readdtd(filename::AbstractString)\n\nRead filename and create a DTD node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reader-node-types","page":"Reference","title":"Reader node types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Node type Integer\nEzXML.READER_NONE 0\nEzXML.READER_ELEMENT 1\nEzXML.READER_ATTRIBUTE 2\nEzXML.READER_TEXT 3\nEzXML.READER_CDATA 4\nEzXML.READER_ENTITY_REFERENCE 5\nEzXML.READER_ENTITY 6\nEzXML.READER_PROCESSING_INSTRUCTION 7\nEzXML.READER_COMMENT 8\nEzXML.READER_DOCUMENT 9\nEzXML.READER_DOCUMENT_TYPE 10\nEzXML.READER_DOCUMENT_FRAGMENT 11\nEzXML.READER_NOTATION 12\nEzXML.READER_WHITESPACE 13\nEzXML.READER_SIGNIFICANT_WHITESPACE 14\nEzXML.READER_END_ELEMENT 15\nEzXML.READER_END_ENTITY 16\nEzXML.READER_XML_DECLARATION 17","category":"page"},{"location":"reference/#Streaming-reader","page":"Reference","title":"Streaming reader","text":"","category":"section"},{"location":"reference/#EzXML.expandtree-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.expandtree","text":"expandtree(reader::StreamReader)\n\nExpand the current node of reader into a full subtree that will be available until the next read of node.\n\nNote that the expanded subtree is a read-only and temporary object. You cannot modify it or keep references to any nodes of it after reading the next node.\n\nCurrently, namespace functions and XPath query will not work on the expanded subtree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodetype-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.nodetype","text":"nodetype(reader::StreamReader)\n\nReturn the type of the current node of reader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodename-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.nodename","text":"nodename(reader::StreamReader)\n\nReturn the name of the current node of reader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodecontent-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.nodecontent","text":"nodecontent(reader::StreamReader)\n\nReturn the content of the current node of reader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.nodedepth-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.nodedepth","text":"nodedepth(reader::StreamReader)\n\nReturn the depth of the current node of reader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.namespace-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.namespace","text":"namespace(reader::StreamReader)\n\nReturn the namespace of the current node of reader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.hasnodecontent-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.hasnodecontent","text":"hasnodecontent(reader::StreamReader)\n\nReturn if the current node of reader has content.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EzXML.hasnodename-Tuple{EzXML.StreamReader}","page":"Reference","title":"EzXML.hasnodename","text":"hasnodename(reader::StreamReader)\n\nReturn if the current node of reader has a node name.\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EzXML.jl is a package for handling XML and HTML documents. The APIs are simple and consistent, and provide a range of functionalities including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reading and writing XML/HTML documents.\nTraversing XML/HTML trees with DOM interfaces.\nSearching elements using XPath.\nProper namespace handling.\nCapturing error messages.\nAutomatic memory management.\nDocument validation.\nStreaming parsing for large XML files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an example of parsing and traversing an XML document:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Load the package.\nusing EzXML\n\n# Parse an XML string\n# (use `readxml(<filename>)` to read a document from a file).\ndoc = parsexml(\"\"\"\n<primates>\n    <genus name=\"Homo\">\n        <species name=\"sapiens\">Human</species>\n    </genus>\n    <genus name=\"Pan\">\n        <species name=\"paniscus\">Bonobo</species>\n        <species name=\"troglodytes\">Chimpanzee</species>\n    </genus>\n</primates>\n\"\"\")\n\n# Get the root element from `doc`.\nprimates = root(doc)\n\n# Iterate over child elements.\nfor genus in eachelement(primates)\n    # Get an attribute value by name.\n    genus_name = genus[\"name\"]\n    println(\"- \", genus_name)\n    for species in eachelement(genus)\n        # Get the content within an element.\n        species_name = nodecontent(species)\n        println(\"  └ \", species[\"name\"], \" (\", species_name, \")\")\n    end\nend\nprintln()\n\n# Find texts using XPath query.\nfor species_name in nodecontent.(findall(\"//species/text()\", primates))\n    println(\"- \", species_name)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are new to this package, read the manual page first. It provides a general guide to the package. The reference page offers a full documentation for each function, and the developer notes page explains about the internal design for developers.","category":"page"},{"location":"devnotes/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"devnotes/","page":"Developer Notes","title":"Developer Notes","text":"This package is built on top of libxml2 and the design is significantly influenced by it. The Node type is a proxy object that points to a C struct allocated by libxml2. There are several node-like types in libxml2 that have common fields to constitute an XML tree. These fields are always located at the first fields of struct definitions, so we can safely use them by casting a pointer to _Node. Especially, the first field, _private, is reserved for applications and EzXML.jl uses it to store a pointer to a Node object. That is, a Node object points to a node struct and the node struct keeps an opposite pointer to the Node object. These bidirectional references are especially important in this package.","category":"page"},{"location":"devnotes/","page":"Developer Notes","title":"Developer Notes","text":"When creating a Node object from a pointer, the constructor first checks whether there is already a proxy object pointing to the same node. If it exists, the constructor extracts the proxy object from the _private field and then return it. Otherwise, it creates a new proxy object and stores a reference to it in _private. As a result, proxy objects pointing to the same node in an XML document are always unique and no duplication happens. This property is fundamental to resource management.","category":"page"},{"location":"devnotes/","page":"Developer Notes","title":"Developer Notes","text":"A Node object has another field called owner that references another Node object or the object itself. The owner node is responsible for freeing memory resources of the node object allocated by libxml2. Freeing memories is done in the finalize_node function, which is registered using finalizer when creating a proxy node. If a node object does not own itself, there is almost nothing to do in finalize_node except canceling (i.e. assigning the null pointer) the _private field.  If a node object owns itself, it finalized all descendant nodes in finalize_node.  In this process, the owner node cancels all _private fields of its descendants because their finalizer may be called after finished freeing nodes, which may result in a segmentation fault. Another important role of keeping owner reference is that it prohibits owner objects from being deallocated by Julia's garbage collecter.","category":"page"},{"location":"devnotes/","page":"Developer Notes","title":"Developer Notes","text":"Since the owner field is not managed by libxml2, EzXML.jl needs to update the field when changing the structure of an XML tree. For example, linking a tree with another tree will lead to an inconsistent situation where descendants nodes reference different owner nodes. update_owners! updates the owner node of a whole tree so that this situation won't happen. Therefore, functions like link! and unlink! update owner objects by calling this function.","category":"page"}]
}
