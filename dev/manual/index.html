<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · EzXML.jl</title><meta name="title" content="Manual · EzXML.jl"/><meta property="og:title" content="Manual · EzXML.jl"/><meta property="twitter:title" content="Manual · EzXML.jl"/><meta name="description" content="Documentation for EzXML.jl."/><meta property="og:description" content="Documentation for EzXML.jl."/><meta property="twitter:description" content="Documentation for EzXML.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EzXML.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Data-types"><span>Data types</span></a></li><li><a class="tocitem" href="#DOM"><span>DOM</span></a></li><li><a class="tocitem" href="#XPath"><span>XPath</span></a></li><li><a class="tocitem" href="#Streaming-API"><span>Streaming API</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../devnotes/">Developer Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIO/EzXML.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIO/EzXML.jl/blob/master/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>This page is dedicated to those who are new to EzXML.jl. It is recommended to read this page before reading other pages to grasp the concepts of the package first. Once you have read it, <a href="../reference/">the reference page</a> would be a better place to find necessary functions. <a href="../devnotes/">The developer notes page</a> is for developers and most users do not need to read it.</p><p>In this manual, we use <code>using EzXML</code> to load the package for brevity.  However, it is recommended to use <code>import EzXML</code> or something similar for non-trivial scripts or packages because EzXML.jl exports a number of names to your environment. These are useful in an interactive session but easily conflict with other names. If you would like to know the list of exported names, please go to the top of src/EzXML.jl, where you will see a long list of type and function names.</p><p>EzXML.jl is built on top of <a href="http://xmlsoft.org/">libxml2</a>, a portable C library compliant to the XML standard. If you are not familiar with XML itself, the following links offer good resources to learn the basic concents of XML:</p><ul><li><a href="https://www.w3schools.com/xml/default.asp">XML Tutorial</a></li><li><a href="https://www.w3schools.com/xml/xml_tree.asp">XML Tree</a></li><li><a href="https://www.w3schools.com/xml/xml_xpath.asp">XML XPath</a></li></ul><h2 id="Data-types"><a class="docs-heading-anchor" href="#Data-types">Data types</a><a id="Data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-types" title="Permalink"></a></h2><p>There are two types that constitute an XML document and its components: <code>Document</code> and <code>Node</code>, respectively. The <code>Document</code> type represents a whole XML document. A <code>Document</code> object points to the topmost node of the XML document, but note that it is different from the root node you see in an XML file.  The <code>Node</code> type represents almost everything in an XML document; elements, attributes, texts, CDATAs, comments, documents, etc. are all <code>Node</code> type objects. These two type names are not exported from EzXML.jl because their names are very general and easily conflict with other names exported from other packages.  However, the user can expect them as public APIs and use them with the <code>EzXML.</code> prefix.</p><p>Here is an example to create an empty XML document using the <code>XMLDocument</code> constructor:</p><pre><code class="language-julia-repl hljs">julia&gt; using EzXML

julia&gt; doc = XMLDocument()
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fd9f1f14370&gt;))

julia&gt; typeof(doc)
EzXML.Document

julia&gt; doc.node
EzXML.Node(&lt;DOCUMENT_NODE@0x00007fd9f1f14370&gt;)

julia&gt; typeof(doc.node)
EzXML.Node

julia&gt; print(doc)  # print an XML-formatted text
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre><p>The text just before the <code>@</code> sign shows the node type (in this example, <code>DOCUMENT_NODE</code>), and the text just after <code>@</code> shows the pointer address (<code>0x00007fd9f1f14370</code>) to a node struct of libxml2.</p><p>Let&#39;s add a root node to the document and a text node to the root node:</p><pre><code class="language-julia-repl hljs">julia&gt; elm = ElementNode(&quot;root&quot;)  # create an element node
EzXML.Node(&lt;ELEMENT_NODE[root]@0x00007fd9f2a1b5f0&gt;)

julia&gt; setroot!(doc, elm)
EzXML.Node(&lt;ELEMENT_NODE[root]@0x00007fd9f2a1b5f0&gt;)

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root/&gt;

julia&gt; txt = TextNode(&quot;some text&quot;)  # create a text node
EzXML.Node(&lt;TEXT_NODE@0x00007fd9f2a81ee0&gt;)

julia&gt; link!(elm, txt)
EzXML.Node(&lt;TEXT_NODE@0x00007fd9f2a81ee0&gt;)

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;some text&lt;/root&gt;
</code></pre><p>Finally you can write the document object to a file using the <code>write</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;out.xml&quot;, doc)
62

julia&gt; print(String(read(&quot;out.xml&quot;)))
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;some text&lt;/root&gt;
</code></pre><p>A <code>Node</code> object has some properties. The most important one would be the <code>type</code> property, which we already saw in the example above. Other properties (<code>name</code>, <code>path</code>, <code>content</code> and <code>namespace</code>) are demonstrated in the following example. The value of a property will be <code>nothing</code> when there is no corresponding value.</p><pre><code class="language-julia-repl hljs">julia&gt; elm = ElementNode(&quot;element&quot;)
EzXML.Node(&lt;ELEMENT_NODE[element]@0x00007fd9f44122f0&gt;)

julia&gt; println(elm)
&lt;element/&gt;

julia&gt; elm.type
ELEMENT_NODE

julia&gt; elm.name
&quot;element&quot;

julia&gt; elm.path
&quot;/element&quot;

julia&gt; elm.content
&quot;&quot;

julia&gt; elm.namespace === nothing
true

julia&gt; elm.name = &quot;ELEMENT&quot;  # set element name
&quot;ELEMENT&quot;

julia&gt; println(elm)
&lt;ELEMENT/&gt;

julia&gt; elm.content = &quot;some text&quot;  # set content
&quot;some text&quot;

julia&gt; println(elm)
&lt;ELEMENT&gt;some text&lt;/ELEMENT&gt;

julia&gt; txt = TextNode(&quot;  text  &quot;)
EzXML.Node(&lt;TEXT_NODE@0x00007fd9f441f3f0&gt;)

julia&gt; println(txt)
  text

julia&gt; txt.type
TEXT_NODE

julia&gt; txt.name
&quot;text&quot;

julia&gt; txt.path
&quot;/text()&quot;

julia&gt; txt.content
&quot;  text  &quot;
</code></pre><p><code>addelement!(&lt;parent&gt;, &lt;child&gt;, [&lt;content&gt;])</code> is handy when you want to add a child element to an existing node:</p><pre><code class="language-julia-repl hljs">julia&gt; user = ElementNode(&quot;User&quot;)
EzXML.Node(&lt;ELEMENT_NODE[User]@0x00007fd9f427c510&gt;)

julia&gt; println(user)
&lt;User/&gt;

julia&gt; addelement!(user, &quot;id&quot;, &quot;167492&quot;)
EzXML.Node(&lt;ELEMENT_NODE[id]@0x00007fd9f41ad580&gt;)

julia&gt; println(user)
&lt;User&gt;&lt;id&gt;167492&lt;/id&gt;&lt;/User&gt;

julia&gt; addelement!(user, &quot;name&quot;, &quot;Kumiko Oumae&quot;)
EzXML.Node(&lt;ELEMENT_NODE[name]@0x00007fd9f42942d0&gt;)

julia&gt; println(user)
&lt;User&gt;&lt;id&gt;167492&lt;/id&gt;&lt;name&gt;Kumiko Oumae&lt;/name&gt;&lt;/User&gt;

julia&gt; prettyprint(user)
&lt;User&gt;
  &lt;id&gt;167492&lt;/id&gt;
  &lt;name&gt;Kumiko Oumae&lt;/name&gt;
&lt;/User&gt;</code></pre><h2 id="DOM"><a class="docs-heading-anchor" href="#DOM">DOM</a><a id="DOM-1"></a><a class="docs-heading-anchor-permalink" href="#DOM" title="Permalink"></a></h2><p>The DOM (Document Object Model) API regards an XML document as a tree of nodes. There is a root node at the top of a document tree and each node has zero or more child nodes. Some nodes (e.g. texts, attributes, etc.) cannot have child nodes.</p><p>For the demonstration purpose, save the next XML in &quot;primates.xml&quot; file.</p><pre><code class="nohighlight hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;primates&gt;
    &lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;
    &lt;genus name=&quot;Pan&quot;&gt;
        &lt;species name=&quot;paniscus&quot;&gt;Bonobo&lt;/species&gt;
        &lt;species name=&quot;troglodytes&quot;&gt;Chimpanzee&lt;/species&gt;
    &lt;/genus&gt;
&lt;/primates&gt;</code></pre><p><code>readxml(&lt;filename&gt;)</code> reads an XML file and builds a document object in memory. Likewise, <code>parsexml(&lt;string or byte array&gt;)</code> parses an XML string or a byte array in memory and builds a document object:</p><pre><code class="language-julia-repl hljs">julia&gt; doc = readxml(&quot;primates.xml&quot;)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fd9f410a5f0&gt;))

julia&gt; data = String(read(&quot;primates.xml&quot;));

julia&gt; doc = parsexml(data)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fd9f4051f80&gt;))
</code></pre><p>Before traversing a document we need to get the root of the document tree. The <code>.root</code> property returns the root element (if any) of a document:</p><pre><code class="language-julia-repl hljs">julia&gt; primates = doc.root  # get the root element
EzXML.Node(&lt;ELEMENT_NODE[primates]@0x00007fd9f4086880&gt;)

julia&gt; genus = elements(primates)  # `elements` returns all child elements.
2-element Vector{EzXML.Node}:
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)

julia&gt; genus[1].type, genus[1].name
(ELEMENT_NODE, &quot;genus&quot;)

julia&gt; genus[2].type, genus[2].name
(ELEMENT_NODE, &quot;genus&quot;)
</code></pre><p>Attribute values can be accessed by its name like a dictionary; <code>haskey</code>, <code>getindex</code>, <code>setindex!</code> and <code>delete!</code> are overloaded for element nodes. Qualified name, which may or may not have the prefix of a namespace, can be used as a key name:</p><pre><code class="language-julia-repl hljs">julia&gt; haskey(genus[1], &quot;name&quot;)  # check whether an attribute exists
true

julia&gt; genus[1][&quot;name&quot;]  # get a value as a string
&quot;Homo&quot;

julia&gt; genus[2][&quot;name&quot;]  # same above
&quot;Pan&quot;

julia&gt; println(genus[1])  # print a &quot;genus&quot; element before updating
&lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;

julia&gt; genus[1][&quot;taxonID&quot;] = &quot;9206&quot;  # insert a new attribute
&quot;9206&quot;

julia&gt; println(genus[1])  # the &quot;genus&quot; element has been updated
&lt;genus name=&quot;Homo&quot; taxonID=&quot;9206&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;
</code></pre><p>In this package, a <code>Node</code> object is regarded as a container of its child nodes. This idea is reflected on its property and function names; for example, a property returning the first child node is named as <code>.firstnode</code> instead of <code>.firstchildnode</code>. All properties and functions provided by the <code>EzXML</code> module are named in this way, and the tree traversal API of a node works on its child nodes by default. Properties (functions) with a direction prefix work on that direction; for example, <code>.nextnode</code> returns the next sibling node and <code>.parentnode</code> returns the parent node.</p><p>Distinction between nodes and elements is what every user should know about before using the DOM API.  There are good explanations on this topic: <a href="http://www.w3schools.com/xml/dom_nodes.asp">http://www.w3schools.com/xml/dom_nodes.asp</a>, <a href="http://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml">http://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml</a>. Some properties (functions) have a suffix like <code>node</code> or <code>element</code> that indicate a node type the property (function) is interested in. For example, <code>.firstnode</code> returns the first child node (if any), which may be a text node, but <code>.firstelement</code> always returns the first element node (if any):</p><pre><code class="language-julia-repl hljs">julia&gt; primates.firstnode
EzXML.Node(&lt;TEXT_NODE@0x00007fd9f409f200&gt;)

julia&gt; primates.firstelement
EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)

julia&gt; primates.firstelement == genus[1]
true

julia&gt; primates.lastnode
EzXML.Node(&lt;TEXT_NODE@0x00007fd9f404bec0&gt;)

julia&gt; primates.lastelement
EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)

julia&gt; primates.lastelement === genus[2]
true
</code></pre><p>Tree traversal properties return <code>nothing</code> when there is no corresponding node:</p><pre><code class="language-julia-repl hljs">julia&gt; primates.firstelement.nextelement === primates.lastelement
true

julia&gt; primates.firstelement.prevelement === nothing
true
</code></pre><p>Here is the list of tree traversal properties:</p><ul><li>The <code>Document</code> type:<ul><li><code>.root</code></li><li><code>.dtd</code></li></ul></li><li>The <code>Node</code> type:<ul><li><code>.document</code></li><li><code>.parentnode</code></li><li><code>.parentelement</code></li><li><code>.firstnode</code></li><li><code>.firstelement</code></li><li><code>.lastelement</code></li><li><code>.lastnode</code></li><li><code>.nextnode</code></li><li><code>.nextelement</code></li><li><code>.nextnode</code></li><li><code>.prevnode</code></li></ul></li></ul><p>If you would like to iterate over child nodes or elements, you can use the <code>eachnode(&lt;parent node&gt;)</code> or the <code>eachelement(&lt;parent node&gt;)</code> function.  The <code>eachnode</code> function generates all nodes including texts, elements, comments, and so on, while <code>eachelement</code> selects only element nodes. <code>nodes(&lt;parent node&gt;)</code> and <code>elements(&lt;parent node&gt;)</code> are handy functions that return a vector of nodes and elements, respectively:</p><pre><code class="language-julia-repl hljs">julia&gt; for node in eachnode(primates)
           @show node
       end
node = EzXML.Node(&lt;TEXT_NODE@0x00007fd9f409f200&gt;)
node = EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)
node = EzXML.Node(&lt;TEXT_NODE@0x00007fd9f4060f70&gt;)
node = EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)
node = EzXML.Node(&lt;TEXT_NODE@0x00007fd9f404bec0&gt;)

julia&gt; for node in eachelement(primates)
           @show node
       end
node = EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)
node = EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)

julia&gt; nodes(primates)
5-element Vector{EzXML.Node}:
 EzXML.Node(&lt;TEXT_NODE@0x00007fd9f409f200&gt;)
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)
 EzXML.Node(&lt;TEXT_NODE@0x00007fd9f4060f70&gt;)
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)
 EzXML.Node(&lt;TEXT_NODE@0x00007fd9f404bec0&gt;)

julia&gt; elements(primates)
2-element Vector{EzXML.Node}:
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f4041a40&gt;)
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fd9f40828e0&gt;)
</code></pre><h2 id="XPath"><a class="docs-heading-anchor" href="#XPath">XPath</a><a id="XPath-1"></a><a class="docs-heading-anchor-permalink" href="#XPath" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/XPath">XPath</a> is a query language for XML. You can retrieve target elements using a short query string. For example, <code>&quot;//genus/species&quot;</code> selects all &quot;species&quot; elements just under a &quot;genus&quot; element.</p><p>The <code>findall</code>, <code>findfirst</code> and <code>findlast</code> functions are overloaded for XPath query and return a vector of selected nodes:</p><pre><code class="language-julia-repl hljs">julia&gt; primates = readxml(&quot;primates.xml&quot;)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fbeddc2a1d0&gt;))

julia&gt; findall(&quot;/primates&quot;, primates)  # Find the &quot;primates&quot; element just under the document
1-element Vector{EzXML.Node}:
 EzXML.Node(&lt;ELEMENT_NODE[primates]@0x00007fbeddc1e190&gt;)

julia&gt; findall(&quot;//genus&quot;, primates)
2-element Vector{EzXML.Node}:
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fbeddc12c50&gt;)
 EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fbeddc16ea0&gt;)

julia&gt; findfirst(&quot;//genus&quot;, primates)
EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fbeddc12c50&gt;)

julia&gt; findlast(&quot;//genus&quot;, primates)
EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fbeddc16ea0&gt;)

julia&gt; println(findfirst(&quot;//genus&quot;, primates))
&lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;
</code></pre><p>If you would like to change the starting node of a query, you can pass the node as the second argument of <code>find*</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; genus = findfirst(&quot;//genus&quot;, primates)
EzXML.Node(&lt;ELEMENT_NODE[genus]@0x00007fbeddc12c50&gt;)

julia&gt; println(genus)
&lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;

julia&gt; println(findfirst(&quot;species&quot;, genus))
&lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
</code></pre><p><code>find*(&lt;xpath&gt;, &lt;node&gt;)</code> automatically registers namespaces applied to <code>&lt;node&gt;</code>, which means prefixes are available in the XPath query. This is especially useful when an XML document is composed of elements originated from different namespaces.</p><p>There is a caveat on the combination of XPath and namespaces: if a document contains elements with a default namespace, you need to specify its prefix to the <code>find*</code> function. For example, in the following example, the root element and its descendants have a default namespace &quot;http://www.foobar.org&quot;, but it does not have its own prefix.  In this case, you need to assign a prefix to the namespance when finding elements in the namespace:</p><pre><code class="language-julia-repl hljs">julia&gt; doc = parsexml(&quot;&quot;&quot;
       &lt;parent xmlns=&quot;http://www.foobar.org&quot;&gt;
           &lt;child/&gt;
       &lt;/parent&gt;
       &quot;&quot;&quot;)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fdc67710030&gt;))

julia&gt; findall(&quot;/parent/child&quot;, doc.root)  # nothing will be found
EzXML.Node[]

julia&gt; namespaces(doc.root)  # the default namespace has an empty prefix
1-element Vector{Pair{String, String}}:
 &quot;&quot; =&gt; &quot;http://www.foobar.org&quot;

julia&gt; ns = namespace(doc.root)  # get the namespace
&quot;http://www.foobar.org&quot;

julia&gt; findall(&quot;/x:parent/x:child&quot;, doc.root, [&quot;x&quot;=&gt;ns])  # specify its prefix as &quot;x&quot;
1-element Vector{EzXML.Node}:
 EzXML.Node(&lt;ELEMENT_NODE[child]@0x00007fdc6774c990&gt;)
</code></pre><h2 id="Streaming-API"><a class="docs-heading-anchor" href="#Streaming-API">Streaming API</a><a id="Streaming-API-1"></a><a class="docs-heading-anchor-permalink" href="#Streaming-API" title="Permalink"></a></h2><p>In addition to the DOM API, EzXML.jl provides a streaming reader of XML files. The streaming reader processes, as the name suggests, a stream of XML data by incrementally reading data from a file instead of reading a whole XML tree into the memory. This enables processing extremely large files with limited memory.</p><p>Let&#39;s use the following XML file (undirected.graphml) that represents an undirected graph in the <a href="http://graphml.graphdrawing.org/">GraphML</a> format (slightly simplified for brevity):</p><pre><code class="nohighlight hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;graphml&gt;
    &lt;graph edgedefault=&quot;undirected&quot;&gt;
        &lt;node id=&quot;n0&quot;/&gt;
        &lt;node id=&quot;n1&quot;/&gt;
        &lt;node id=&quot;n2&quot;/&gt;
        &lt;node id=&quot;n3&quot;/&gt;
        &lt;node id=&quot;n4&quot;/&gt;
        &lt;edge source=&quot;n0&quot; target=&quot;n2&quot;/&gt;
        &lt;edge source=&quot;n1&quot; target=&quot;n2&quot;/&gt;
        &lt;edge source=&quot;n2&quot; target=&quot;n3&quot;/&gt;
        &lt;edge source=&quot;n3&quot; target=&quot;n4&quot;/&gt;
    &lt;/graph&gt;
&lt;/graphml&gt;</code></pre><p>The API of a streaming reader is quite different from the DOM API.  The first thing you needs to do is to create an <code>EzXML.StreamReader</code> object using the <code>open</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; reader = open(EzXML.StreamReader, &quot;undirected.graphml&quot;)
EzXML.StreamReader(&lt;READER_NONE@0x00007f9fe8d67340&gt;)
</code></pre><p>The stream reader is stateful and parses components by pulling them from the stream. For example, when it reads an element from the stream, it changes the state to <code>READER_ELEMENT</code> and some information becomes accessible.  Its reading state is advanced by the <code>iterate(reader)</code> method:</p><pre><code class="language-julia-repl hljs">julia&gt; reader.type  # the initial state is READER_NONE
READER_NONE

julia&gt; iterate(reader);  # advance the reader&#39;s state

julia&gt; reader.type  # now the state is READER_ELEMENT
READER_ELEMENT

julia&gt; reader.name  # the reader has just read a &quot;&lt;graphml&gt;&quot; element
&quot;graphml&quot;

julia&gt; iterate(reader);

julia&gt; reader.type  # now the state is READER_SIGNIFICANT_WHITESPACE
READER_SIGNIFICANT_WHITESPACE

julia&gt; reader.name
&quot;#text&quot;

julia&gt; iterate(reader);

julia&gt; reader.type
READER_ELEMENT

julia&gt; reader.name  # the reader has just read a &quot;&lt;graph&gt;&quot; element
&quot;graph&quot;

julia&gt; reader[&quot;edgedefault&quot;]  # attributes are accessible
&quot;undirected&quot;
</code></pre><p>While reading data, a stream reader provides the following properties:</p><ul><li><code>.type</code>:  node type it has read</li><li><code>.depth</code>: depth of the current node</li><li><code>.name</code>: name of the current node</li><li><code>.content</code>: content of the current node</li><li><code>.namespace</code>: namespace of the current node</li></ul><p><code>iterate(reader)</code> returns <code>nothing</code> to indicate that there are no more data available from the file. When you finished reading data, you need to call <code>close(reader)</code> to release allocated resources:</p><pre><code class="language-julia-repl hljs">julia&gt; reader = open(EzXML.StreamReader, &quot;undirected.graphml&quot;)
EzXML.StreamReader(&lt;READER_NONE@0x00007fd642e80d90&gt;)

julia&gt; while (item = iterate(reader)) != nothing
           @show reader.type, reader.name
       end
(reader.type, reader.name) = (READER_ELEMENT, &quot;graphml&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;graph&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_END_ELEMENT, &quot;graph&quot;)
(reader.type, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(reader.type, reader.name) = (READER_END_ELEMENT, &quot;graphml&quot;)

julia&gt; reader.type, reader.name
(READER_NONE, nothing)

julia&gt; close(reader)  # close the reader
</code></pre><p>The <code>open(...) do ... end</code> pattern can be written as:</p><pre><code class="language-julia-repl hljs">julia&gt; open(EzXML.StreamReader, &quot;undirected.graphml&quot;) do reader
           # do something
       end
</code></pre><p>EzXML.jl overloads the <code>Base.iterate</code> function to make a streaming reader iterable via the <code>for</code> loop. Therefore, you can iterate over all components without explicitly calling <code>iterate</code> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; reader = open(EzXML.StreamReader, &quot;undirected.graphml&quot;)
EzXML.StreamReader(&lt;READER_NONE@0x00007fd642e9a6b0&gt;)

julia&gt; for typ in reader
           @show typ, reader.name
       end
(typ, reader.name) = (READER_ELEMENT, &quot;graphml&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;graph&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;node&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_ELEMENT, &quot;edge&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_END_ELEMENT, &quot;graph&quot;)
(typ, reader.name) = (READER_SIGNIFICANT_WHITESPACE, &quot;#text&quot;)
(typ, reader.name) = (READER_END_ELEMENT, &quot;graphml&quot;)

julia&gt; close(reader)
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 27 July 2025 15:02">Sunday 27 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
